# -*- coding: utf-8 -*-import arcpyimport osfrom arcpy.sa import RemapValueclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [ViewshedGenerator]class ViewshedGenerator:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "ViewshedGenerator2"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        observer_pts = arcpy.Parameter(            displayName="Observer Inputs",            name="observer_points",            datatype="DEFeatureClass",            parameterType="Required",            direction="Input"        )        estimate_dsm = arcpy.Parameter(            displayName="Estimate DSM?",            name="estimate_dsm",            datatype="GPBoolean",            parameterType="Required",            direction="Input"        )        estimate_dsm.value = True  # default        elevation_raster = arcpy.Parameter(            displayName="Elevation Raster",            name="elevation_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input"        )        nlcd_raster = arcpy.Parameter(            displayName="NLCD Raster",            name="nlcd_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input"        )        buffer_distance = arcpy.Parameter(            displayName="Tower Range",            name="buffer_distance",            datatype="GPLinearUnit",            parameterType="Required",            direction="Input"        )        output_gdb = arcpy.Parameter(            displayName="Output GDB",            name="output_gdb",            datatype="DEWorkspace",            parameterType="Required",            direction="Input"        )        scoring_params = arcpy.Parameter(            displayName="Scoring Parameters",            name="scoring_parameters",            datatype="DEFeatureClass",            parameterType="Required",            direction="Input",            multiValue=True        )        observer_height = arcpy.Parameter(            displayName="Observer Height",            name="observer_height",            datatype="GPLinearUnit",            parameterType="Required",            direction="Input"        )        return [            observer_pts,            estimate_dsm,            elevation_raster,            nlcd_raster,            buffer_distance,            output_gdb,            scoring_params,            observer_height        ]    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        estimate = parameters[1]        nlcd_param = parameters[3]        if estimate.value:            nlcd_param.enabled = True            nlcd_param.parameterType = "Required"        else:            nlcd_param.enabled = False            nlcd_param.parameterType = "Optional"            nlcd_param.value = None        # clear value when disabled        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def generateviewshed(self, elevation_raster, observer_points, output, output_location, buffer, observer_height):        try:            viewshed = arcpy.sa.Viewshed2(            in_raster = elevation_raster,            in_observer_features = observer_points,            analysis_type = "FREQUENCY",            outer_radius = buffer,            observer_offset = observer_height)            # declare output file (including file name)            output_location = os.path.join(output_location, output)            # save viewshed at that location            viewshed.save(output_location)            # return viewshed to save viewshed in the list.            return viewshed        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def buffer(self, points, buffer, distance, num):        # declare output file name with qualifier(num)        output = buffer + str(num)        # generate buffer        try:            file = arcpy.analysis.Buffer(points, output, distance, "", "", "", "")            # return file to add to the buffer list            return file        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def extract_by_mask(self, buffer_output, viewshed, i, output_location):        try:            extracted = arcpy.sa.ExtractByMask(viewshed, buffer_output, "", "")            # save extracted file            extracted.save(os.path.join(output_location, "extracted"+str(i)))            # return extracted file to add it to the list            return extracted        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def reclassify(self, raster, output_fc, location):        # reclassify raster to only include the covered area, excluding areas not covered(value = 0)        try:            # reclassify            reclass = arcpy.sa.Reclassify(raster, "Value", RemapValue([[0, "NODATA"], [1, 1]]), "")            # save reclassified file            reclass.save(output_fc)            # print to confirm to user that the reclassification was successful            # return reclassified output to add it to a list            return reclass        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def dissolve(self, features, output):        # merge polygon features together        try:            merged = arcpy.management.Merge(features, "in_memory\\temp_merge")            return arcpy.management.Dissolve(merged, output)        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def spatialJoin(self, polygon, data, output, type):        try:            # join covered area with other features            joined_features = arcpy.analysis.SpatialJoin(polygon, data, output, type, "KEEP_ALL")            # return joined feature class            return joined_features        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def toPolygon(self, dataset, output_polygon, char):        try:            # Convert raster to polygon            output_polygon += char            arcpy.RasterToPolygon_conversion(dataset, output_polygon, "NO_SIMPLIFY", "VALUE")            # return output polygon for further analysis            return output_polygon        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def aggregate(self, input, output, distance):        try:            return arcpy.cartography.AggregatePolygons(input, output, distance) #can add this as a fourth input: ".25 SquareMiles"        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def identify_multivalue(self, fc):        with arcpy.da.SearchCursor(fc, ["score"]) as cursor:            try:                first_row = next(cursor)                score = first_row[0]            except StopIteration:                return False  # Empty feature class, no scores to compare            for row in cursor:                if row[0] != score:                    return True        return False    def convertToPoints(self, shape, type):        if type == "Polygon":            lines = arcpy.management.PolygonToLine(shape, "Observer_Line")        else: lines = shape        arcpy.AddMessage(lines)        return arcpy.management.GeneratePointsAlongLines(lines, "Observer_Points", "PERCENTAGE", Distance=None, Percentage=10, Include_End_Points="END_POINTS")    def calculate_score(self, viewshed, data_list, output_name, output_location):        # declare name qualifier        num = 0        # temporary list for polygons        polygon_list = []        # iterate through all viewshed rasters        for raster in viewshed:            # increment qualifier by num            num += 1            # declare new output name            output = output_name + str(num)            # reclassify viewsheds            reclassified = self.reclassify(raster, output, output_location)            arcpy.AddMessage(f"{reclassified} has {arcpy.GetCount_management(reclassified)[0]} features")            # convert raster to polygon and add to list of polygons            polygon = self.toPolygon(reclassified, output, "poly" + str(num))            arcpy.AddMessage(f"{polygon} has {arcpy.GetCount_management(polygon)[0]} features")            polygon_list.append(self.aggregate(polygon, "final_polygon" + str(num), "120 Meters"))            arcpy.AddMessage(f"[{polygon_list[num-1]} has {arcpy.GetCount_management(polygon_list[num-1])[0]} features")        arcpy.AddMessage(f"Polygon list: {polygon_list}")        for d in polygon_list:            arcpy.AddMessage(f"{d} has {arcpy.GetCount_management(d)[0]} features")        arcpy.AddMessage("performing joins")        score_list = []        dissolved = []        for poly in range(len(polygon_list)):            original = polygon_list[poly]            score = 0            results = []            for i, dataset in enumerate(data_list, start=1):                multivalue = self.identify_multivalue(dataset)                path = str(dataset)                name = path.split("\\")[-1]                uneditable_fields = [f.name for f in arcpy.ListFields(dataset) if not f.editable]                # Define the fields to keep (score field and required system fields)                keepers = uneditable_fields + ["Shape", "Score"]  # Add any additional fields you need to keep                fields_to_delete = [f.name for f in arcpy.ListFields(dataset) if f.name not in keepers]                arcpy.CopyFeatures_management(dataset, "in_memory\\compact" + str(poly) + "_" + str(i))                if fields_to_delete:                    arcpy.DeleteField_management("in_memory\\compact" + str(poly) + "_" + str(i), fields_to_delete)                temp_fc = f"in_memory\\temp_join_{poly}_{i}"  # Store intermediate results in memory                output_fc = self.spatialJoin(original, "in_memory\\compact" + str(poly) + "_" + str(i), temp_fc, "JOIN_ONE_TO_ONE")                scored = self.add(output_fc, "score", "join_count", multivalue)                score += scored[0]                counted = scored[1]                results.append([name, scored[0], counted])            dissolved.append(self.dissolve(original, "Final_Cell_Range" + str(poly)))            # Save the final output to disk before exporting to Excel            final_fc = f"{output_location}\\FinalJoined{poly}"            arcpy.CopyFeatures_management(output_fc, final_fc)            arcpy.AddMessage([f.name for f in arcpy.ListFields(final_fc)])            score_list.append([poly, score, results])        arcpy.AddMessage(f"Dissolved list: {dissolved}")        for d in dissolved:            arcpy.AddMessage(f"{d} has {arcpy.GetCount_management(d)[0]} features")        arcpy.AddMessage(dissolved)        arcpy.management.Merge(dissolved, "Point_Ranges")        return score_list    def toOriginalGeometry(self, points, shape):        shape = self.spatialJoin(shape, points, "Scored_Original_Geometry", "JOIN_ONE_TO_MANY")        return shape    def add(self, table, score, count, multivalue):        total_score = 0        counter = 0        with arcpy.da.SearchCursor(table, [score, count]) as cursor:            for row in cursor:                score_val, count_val = row                # Skip rows with None values in score or count                if score_val is None or count_val is None:                    continue                if not multivalue:                    counter += count_val                    total_score += score_val * count_val                else:                    total_score = max(total_score, score_val)        if multivalue:            counter = 1        return [total_score, counter]    def execute(self, parameters, messages):        """The source code of the tool."""        observer_points = parameters[0].valueAsText        estimate_dsm = parameters[1].valueAsText        elevation_raster = parameters[2].valueAsText        nlcd_raster = parameters[3].valueAsText        buffer_distance = parameters[4].valueAsText        output_location = parameters[5].valueAsText        criteria = parameters[6].valueAsText.split(";")        observer_height = parameters[7].valueAsText        arcpy.env.workspace = output_location        '''Dissolve polylines if necessary'''        temp = []        for i in criteria:            name = i.split("\\")[-1]            type = arcpy.Describe(i)            arcpy.AddMessage(type.shapeType)            if type.shapeType in ["Polyline", "Polygon"] and not self.identify_multivalue(i):                arcpy.AddMessage("dissolving for join")                original = arcpy.management.Dissolve(i, f"in_memory\\{name}", ["score"])                temp.append(original)            else:                temp.append(i)        type = arcpy.Describe(observer_points)        """////////////////////////////////////////////////////////////////////////////////////////////////////////"""        '''Ensure observer input are points. Can accept polygon or polylines as well.'''        if type.shapeType in ["Polyline", "Polygon"]:            original_shape = observer_points            observer_points = self.convertToPoints(observer_points, type.shapeType)        """////////////////////////////////////////////////////////////////////////////////////////////////////////"""        '''Estimate DSM if necessary.'''        if estimate_dsm:            elev = arcpy.sa.Raster(elevation_raster)            nlcd = arcpy.sa.Raster(nlcd_raster)            remap = RemapValue([                [11, 0],                [21, 5],                [22, 7],                [23, 10],                [24, 12],                [31, 0],                [41, 25],                [42, 30],                [43, 27],                [52, 2],                [71, 1],                [81, 1],                [82, 2],                [90, 1],                [95, 2]            ])            height_raster = arcpy.sa.Reclassify(nlcd, "Value", remap)            dsm = elev + height_raster            output_path = arcpy.env.workspace + "/estimated_dsm"            dsm.save(output_path)            elevation_raster = output_path        '''Reset Criteria as the new list with dissolved features'''        criteria = temp        arcpy.AddMessage(criteria)        buffer_fc = os.path.join(output_location, "buffer") # Pathway to buffer location        point_list = []        viewshed_list = []        extracted_viewshed = []        '''Use a Search Cursor to loop through observer points and add them to the list'''        with arcpy.da.SearchCursor(observer_points, ["SHAPE@"]) as cursor:            for row in cursor:                point_list.append(row[0])        '''Now loop through the point_list and generate the viewshed'''        output_name_qualifier = 0        for point in point_list:            output_name_qualifier += 1            output = "viewshed" + str(output_name_qualifier)            if arcpy.Exists("in_memory/temp_point_fc"):                arcpy.Delete_management("in_memory/temp_point_fc")            temp_point_fc = arcpy.management.CopyFeatures([point], "in_memory/temp_point_fc")            fields = [f.name for f in arcpy.ListFields(temp_point_fc)]            viewshed_list.append(self.generateviewshed(elevation_raster, temp_point_fc, output, output_location, buffer_distance, observer_height))            arcpy.AddMessage(output + "complete!")        scores = self.calculate_score(viewshed_list, criteria, "Final_Score", output_location)        arcpy.AddMessage(scores)        # Add score field        try:            arcpy.management.AddField(observer_points, "score", "DOUBLE")        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any        # Update score field        try:            with arcpy.da.UpdateCursor(observer_points, ["score"]) as cursor:                for i, row in enumerate(cursor):                    row[0] = scores[i][1]                    cursor.updateRow(row)        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any        # Update scoring parameter fields with [score, count]        try:            for i, dataset in enumerate(criteria):                path = str(dataset)                name = path.split("\\")[-1]                arcpy.management.AddField(observer_points, name, "TEXT")                with arcpy.da.UpdateCursor(observer_points, [name]) as cursor:                    for j, row in enumerate(cursor):                        text = f"Score: {scores[j][2][i][1]} Count: {scores[j][2][i][2]}"                        row[0] = text                        cursor.updateRow(row)        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any        """////////////////////////////////////////////////////////////////////////////////////////////////////////"""        # If polygon, summarize to get polygon score instead of points score.        if type.shapeType in ["Polyline", "Polygon"]:            self.toOriginalGeometry(observer_points, original_shape)        """////////////////////////////////////////////////////////////////////////////////////////////////////////"""        arcpy.AddMessage("Deleting intermediate data.")        # Clean up intermediate data        arcpy.management.Delete(temp_point_fc)        for i in range(len(point_list)):            index = i+1            arcpy.management.Delete("FinalJoined"+str(i))            arcpy.management.Delete("Final_Score"+str(index))            arcpy.management.Delete("Final_Score"+str(index)+"poly"+str(index))            arcpy.management.Delete("final_polygon"+str(index))            arcpy.management.Delete("Final_Cell_Range"+str(i))            arcpy.management.Delete("viewshed"+str(index))        # confirm that script ran till the end        arcpy.AddMessage("done")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return